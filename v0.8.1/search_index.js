var documenterSearchIndex = {"docs":
[{"location":"generated/man/params_in_struct/#Parameters","page":"Parameters","title":"Parameters","text":"NamedTrajectory.jl support passing parameters as a Tuple when construct a NamedTrajectory.\n\nusing NamedTrajectories\n\nFirst we need to define number of timesteps and timestep\n\nN = 10\ndt = 0.1\n\nthen build named tuple of components and data matrices.\n\ncomponents = (\n    x = rand(3, N),\n    u = rand(2, N),\n    Δt = fill(dt, 1, N),\n)\n\nwe must specify a timestep and control variable for the trajectory.\n\ntimestep = :Δt\ncontrol = :u\n\nsome global params as a NamedTuple\n\nparams = (\n    α = rand(1),\n    β = rand(1)\n)\n\nwe can now create a NamedTrajectory object with parameters specification.\n\ntraj = NamedTrajectory(components, params; timestep=timestep, controls=control)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/man/modifying/#Modifying-trajectories","page":"Modifying trajectories","title":"Modifying trajectories","text":"Modifying existing trajectories can be useful for a variety of reasons. Sometimes, you may want to change the values of the states, controls, or other components of the trajectory. Other times, you may want to add or remove components from the trajectory.\n\nusing NamedTrajectories\n\nCreate a random trajectory with 5 time steps, a state variable x of dimension 3, and a control variable u of dimension 2\n\ntraj = rand(NamedTrajectory, 5)\ntraj.names\n\nAdd a new state variable y to the trajectory. Notice this is in-place.\n\ny_data = rand(4, 5)\ntraj = add_component(traj, :y, y_data)\ntraj.names\n\nRemove the state variable y from the trajectory. This is not in place.\n\nrestored_traj = remove_component(traj, :y)\nrestored_traj.names","category":"section"},{"location":"generated/man/modifying/#Adding-suffixes","page":"Modifying trajectories","title":"Adding suffixes","text":"Another common operation is to add or remove a suffix from the components of a trajectory. This can be useful when you want to create a modified version of a trajectory that is related to the original trajectory in some way, or when you want to create a new trajectory that is a combination of two or more existing trajectories.\n\nFor now, these tools are used to create a new trajectory.\n\nAdd a suffix \"_new\" to the state variable x\n\nmodified_traj = add_suffix(traj, \"_modified\")\nmodified_traj.names\n\nThe modified trajectory contains the same data\n\nmodified_traj.x_modified == traj.x","category":"section"},{"location":"generated/man/modifying/#Merging-trajectories","page":"Modifying trajectories","title":"Merging trajectories","text":"You can also merge two or more trajectories into a single trajectory. This can be useful when you want to combine data. Mergining trajectories is like taking a direct sum of the underlying data.\n\nMerge the original trajectory with the modified trajectory\n\nmerged_traj = merge(traj, modified_traj)\nmerged_traj.names |> println\n\nYou can also extract a specific suffix from the components of a trajectory\n\nextracted_traj = get_suffix(merged_traj, \"_modified\")\nextracted_traj.names\n\nIf you want the original names, you can remove the suffix\n\noriginal_traj = get_suffix(merged_traj, \"_modified\", remove=true)\noriginal_traj.names","category":"section"},{"location":"generated/man/modifying/#Merging-with-conflicts","page":"Modifying trajectories","title":"Merging with conflicts","text":"If there are any conflicting symbols, you can specify how to resolve the conflict.\n\nconflicting_traj = rand(NamedTrajectory, 5)\ntraj.names, conflicting_traj.names\n\nIn this case, keep the u data from the first trajectory and the x data and timestep from the second trajectory\n\nmerged_traj = merge(traj, conflicting_traj; merge_names=(u=1, x=2, Δt=2))\nprintln(merged_traj.u == traj.u, \", \", merged_traj.u == conflicting_traj.u)\nprintln(merged_traj.x == traj.x, \", \", merged_traj.x == conflicting_traj.x)\n\nMerged names\n\nmerged_traj.names","category":"section"},{"location":"generated/man/modifying/#Advanced-usage","page":"Modifying trajectories","title":"Advanced usage","text":"Sometimes it may be desirable to have direct access to the underlying data matrix/vector associated with the trajectory. In other circumstances it is more useful to employ the built-in per-component and per-knot-point indexing functionality. We detail the relationship between these different methods of access here.\n\ntraj = rand(NamedTrajectory, 5)\n\nThe \"backing store\" of a NamedTrajectory is its datavec field, a Vector{<:Real}:\n\ntraj.datavec\n\nThe data field holds a reshaped \"view\" of the \"backing store\", in a form that is somewhat easier to work with:\n\ntraj.data","category":"section"},{"location":"generated/man/modifying/#Indexing","page":"Modifying trajectories","title":"Indexing","text":"The data matrix is of dimension (traj.dim, traj.N), where length(traj.names) == traj.dim\n\nThe nth component's indices are given by traj.components[traj.names[n]]\n\nprintln(traj.names)\nprintln(traj.components)\n\nFor instance, the indices of a given component at a given knot point are given as follows:\n\nidx = 1 # x\nk = 3\nslice = traj.datavec[((k - 1) * traj.N) .+ traj.components[traj.names[idx]]]\nprintln(slice == traj[k].x == traj.x[:, k])\n\nMore generally, the indices of a given component across all knot points are given as follows:\n\nidx = 1 # x\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.N])\nidx = 2 # u\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.N])","category":"section"},{"location":"generated/man/modifying/#Writability","page":"Modifying trajectories","title":"Writability","text":"","category":"section"},{"location":"generated/man/modifying/#Views-and-Backing-Stores","page":"Modifying trajectories","title":"Views and Backing Stores","text":"In Julia, a \"view\" (SubArray) is intrinsically linked to some \"parent\" Array. Any in-place modification of one is reflected by the other.\n\nThe following are \"safe\" operations on a NamedTrajectory (in-place modification of the datavec):\n\ntraj = rand(NamedTrajectory, 5)\ntraj.datavec\nprintln(traj.datavec)\ntraj.datavec[1] *= 0.\nprintln(traj.datavec)\ntraj.datavec[:] = rand(length(traj.datavec))\nprintln(traj.datavec)\n\nThe following is an example of an \"unsafe\" operation (non-in-place modification of the datavec):\n\ntraj = rand(NamedTrajectory, 5)\nprintln(traj.datavec == traj.data[:])\ntraj.datavec = rand(length(traj.datavec))\nprintln(traj.datavec == traj.data[:]) # the `data` field now points to a \"backing store\" that is no longer accessible via `traj.datavec`; this will lead to undefined behavior:\n\nIn general, reassigning the values of any of the fields of a trajectory may lead to undefined behavior:\n\nfieldnames(NamedTrajectory)\n\nTODO:\n\nPrevent this issue by catching attempts to set sensitive fields in Base.setproperty!(::NamedTrajectory, ::Symbol, ::Any) (datavec and data are the primary concern in this regard; however, issuing a warning of some kind may be appropriate).\nParticularly because it is confusing that traj.datavec = zeros(length(datavec)) is \"discouraged\", while traj.x = zeros(traj.dims.x, traj.N) and traj[1].x = zeros(traj.dims.x) are both valid.","category":"section"},{"location":"generated/man/modifying/#Components-and-Knot-Points","page":"Modifying trajectories","title":"Components and Knot Points","text":"traj = rand(NamedTrajectory, 5)\n\nTrajectory components are accessible (as a \"view\") via getproperty:\n\ntraj.x\n\nComponents are also writable via setproperty!:\n\ntraj.x = rand(traj.dims.x, traj.N)\ntraj.x\n\nor may be modified directly:\n\ntraj.x[1] *= 0.\ntraj.x\n\nKnot points are likewise accessible via getindex:\n\ntraj[1]\n\nA KnotPoint behaves much like a NamedTrajectory, with respect to getting, setting, and/or modifying its components:\n\ntraj[1].u\n\ntraj[1].u = rand(traj.dims.u)\ntraj[1].u\n\ntraj[1].u[1] *= 0\ntraj[1].u\n\nThe parent trajectory will reflect any modifications made in this fashion:\n\ntraj.datavec\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"lib/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"lib/#NamedTrajectory-methods","page":"Library","title":"NamedTrajectory methods","text":"","category":"section"},{"location":"lib/#Random-trajectory-methods","page":"Library","title":"Random trajectory methods","text":"","category":"section"},{"location":"lib/#Struct-Methods","page":"Library","title":"Struct Methods","text":"","category":"section"},{"location":"lib/#Trajectory-Utilities","page":"Library","title":"Trajectory Utilities","text":"","category":"section"},{"location":"lib/#Interpolation-Methods","page":"Library","title":"Interpolation Methods","text":"","category":"section"},{"location":"lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","page":"Library","title":"Base.merge","text":"merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory})\n\nReturns a new NamedTrajectory object by merging NamedTrajectory objects. \n\nMerge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names.\n\nKeyword Arguments\n\ntimestep::Symbol: The timestep symbol to use for free time problems. Default to the last trajectory.\nmerge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing: The names to merge by index.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_component-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component","text":"add_component(traj, name::Symbol, data::AbstractVecOrMat)\n\nAdd a component to the trajectory.\n\nKeyword arguments:     - type::Symbol: The type of the component, can be :state, :control, :slack, or :global. Default is :state.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_components-Tuple{NamedTrajectory, NamedTuple}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_components","text":"add_components(traj, comps)\n\nAdd components to the trajectory.\n\nKeyword arguments:     - type::Symbol: The type of the component, can be :state, :control, :slack, or :global. Default is :state.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_control_derivatives-Tuple{NamedTrajectory, Int64}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_control_derivatives","text":"add_control_derivatives(\n    traj::NamedTrajectory,\n    n_derivatives::Int;\n    control_name::Symbol=:u,\n    derivative_bounds::Union{Nothing, Tuple{Vararg{VectorBound}}}=nothing,\n    zero_initial_and_final_derivative::Bool=false,\n    random_init::Bool=false,\n    drive_derivative_σ::Float64=0.1\n)\n\nAdd control derivatives to an existing trajectory.\n\nTakes an existing NamedTrajectory with a control variable and adds its time derivatives (e.g., u̇, ü) as new trajectory components. Can either compute derivatives using finite  differences or initialize them randomly.\n\nArguments\n\ntraj::NamedTrajectory: Existing trajectory with control variable\nn_derivatives::Int: Number of derivatives to add (1 for u̇, 2 for u̇ and ü, etc.)\n\nKeyword Arguments\n\ncontrol_name::Symbol=:u: Name of the control variable in the trajectory\nderivative_bounds::Union{Nothing, Tuple{Vararg{VectorBound}}}=nothing: Bounds for each derivative level (du, ddu, ...)\nzero_initial_and_final_derivative::Bool=false: Enforce zero first derivative at boundaries\nrandom_init::Bool=false: If true, randomly initialize derivatives instead of computing via finite differences\ndrive_derivative_σ::Float64=0.1: Standard deviation for random derivative initialization (only used if random_init=true)\n\nReturns\n\nNamedTrajectory: New trajectory with control derivatives added\n\nExamples\n\n# Add first and second derivatives computed via finite differences\ntraj_smooth = add_control_derivatives(\n    traj, \n    2; \n    derivative_bounds=(([-2.0, -2.0], [2.0, 2.0]), ([-5.0, -5.0], [5.0, 5.0]))\n)\n\n# Add derivative with zero boundary conditions\ntraj_smooth = add_control_derivatives(\n    traj,\n    1;\n    zero_initial_and_final_derivative=true\n)\n\n# Randomly initialize derivatives\ntraj_random = add_control_derivatives(\n    traj,\n    2;\n    random_init=true,\n    drive_derivative_σ=0.05\n)\n\nNotes\n\nThe original trajectory is not modified; a new trajectory is returned\nWhen random_init=false, derivatives are computed using finite differences: du/dt ≈ Δu/Δt\nWhen random_init=true, derivatives are sampled from N(0, drivederivativeσ²)\nThe penultimate point of each derivative is adjusted to ensure smooth transitions (finite difference mode only)\nNew derivative components become part of the trajectory controls\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_suffix","text":"add_suffix(obj::T, suffix::String)\n\nAdd the suffix to the symbols of the object.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{Int64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","text":"get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int})\n\nReturns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols.\n\nThe filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","text":"get_components(names, ::NamedTrajectory)\n\nReturns a NamedTuple containing the names and corresponding data matrices of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","text":"get_duration(::NamedTrajectory)\n\nReturns the duration of a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_suffix","text":"get_suffix(obj::T, suffix::String; remove::Bool=false)\n\nGet the data with the suffix from the object. Remove the suffix if remove=true.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","text":"get_times(traj)::Vector{Float64}\n\nReturns the times of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","text":"get_timesteps(::NamedTrajectory)\n\nReturns the timesteps of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","text":"merge_outer(objs::AbstractVector{<:Any})\n\nMerge objects. An error is reported if a key collision is detected.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","text":"remove_component(traj, name::Symbol)\n\nRemove a component from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","text":"remove_components(traj, names::Vector{Symbol})\n\nRemove a set of components from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_suffix","text":"remove_suffix(obj::T, suffix::String)\n\nRemove the suffix from the symbols of the object.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","text":"update!(traj, datavec::AbstractVector{Float64})\n\nUpdate the trajectory with a new datavec.\n\nKeyword arguments:     - type::Symbol: The type of the datavec, can be :data, :global, or :both. Default is global.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","text":"update!(traj, name::Symbol, data::AbstractMatrix{Float64})\n\nUpdate a component of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!-Tuple{NamedTrajectory, Symbol, Any}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","text":"update_bound!(traj, name, new_bound)\n\nUpdate the bound of a component of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getproperty-Tuple{KnotPoint, Symbol}","page":"Library","title":"Base.getproperty","text":"getproperty(slice::KnotPoint, symb::Symbol)\n\nReturns the component of the knot point with name symb (as a view) or the property of the knot point with name symb.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.setproperty!-Tuple{KnotPoint, Symbol, Any}","page":"Library","title":"Base.setproperty!","text":"setproperty!(slice::KnotPoint, symb::Symbol, val::Any)\n\nDispatches setting properties of knot points as either setting a component or a property via update! or setfield!, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsKnotPoint.update!-Tuple{KnotPoint, Symbol, AbstractVector{Float64}}","page":"Library","title":"NamedTrajectories.MethodsKnotPoint.update!","text":"update!(slice::KnotPoint, symb::Symbol, data::AbstractVector{Float64})\n\nUpdate a component of the knot point.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","page":"Library","title":"Base.rand","text":"rand(\n    ::Type{NamedTrajectory},\n    N::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n)\n\nCreate a random NamedTrajectory with N knot points, a state variable x of dimension  state_dim, and a control variable u of dimension control_dim. The time step is a symbol timestep_name and the time step value is timestep_value. \n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory{R <: Real}\n\nContainer for trajectory optimization problems, which includes the trajectory data, bounds dimensions, initial and final conditions, goal states, and components.\n\nThis struct is designed to hold trajectory data in a named format, allowing for easy access to knot points by Symbol.\n\nNamedTrajectory is designed to make allocation-free access easy to write. The data can be updated after construction, but the fields cannot.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N, NamedTuple{GN, <:Tuple{Vararg{AbstractVector{<:Real}}}} where GN}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data, global_components_data)\n\nConstruct a NamedTrajectory from component data and global component data\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data)\n\nConstruct a NamedTrajectory from component data.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractVecOrMat{<:Real}}}} where N}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data::NamedTuple, timestep; kwargs...)\n\nConstruct a NamedTrajectory from mixed Matrix/Vector component data.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{NamedTrajectory}, Tuple{R}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(data, traj)\n\nConstruct a NamedTrajectory from an existing NamedTrajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractMatrix{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(data, components; kwargs...)\n\nConstruct a NamedTrajectory from a data matrix and components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractVector{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N, Int64}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(datavec, components, N)\n\nConstruct a named trajectory from a data vector, components, and knot points.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims-Tuple{NamedTuple, NamedTuple{<:Any, <:Tuple{Vararg{Int64}}}}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims","text":"get_bounds_from_dims(bounds, dims; dtype=Float64)\n\nProcess bounds from allowed types using dims and convert to dtype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs-Union{Tuple{R}, Tuple{Vector{Pair{Symbol, Int64}}, NamedTuple{bname, <:Tuple{Vararg{Tuple{R⃗, R⃗}}} where R⃗<:AbstractVector{R}} where bname, NamedTuple{iname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where iname, NamedTuple{fname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where fname, NamedTuple{gname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where gname}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs","text":"inspect_dims_pairs(dims_pairs, bounds, initial, final, goal)\n\nCheck for proper formatting of trajectory components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.inspect_names-NTuple{6, Tuple{Vararg{Symbol}}}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_names","text":"inspect_names(names, controls, initial, final, goal, bounds)\n\nCheck for missing names in the trajectory components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructKnotPoint.KnotPoint","page":"Library","title":"NamedTrajectories.StructKnotPoint.KnotPoint","text":"KnotPoint constructor\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.Utils.derivative-Tuple{AbstractMatrix, AbstractVecOrMat}","page":"Library","title":"NamedTrajectories.Utils.derivative","text":"derivative(X::AbstractMatrix, Δt::AbstractVecOrMat)\nderivative(X::AbstractMatrix, Δt::Float64)\n\nCompute the derivative of the data matrix X.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.Utils.integral-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"NamedTrajectories.Utils.integral","text":"integral(X::AbstractMatrix, Δt::AbstractVector)\nintegral(X::AbstractMatrix, Δt::Float64)\n\nCompute the integral of the data matrix X.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.trajectory_interpolation","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.trajectory_interpolation","text":"trajectory_interpolation(\n    traj::NamedTrajectory,\n    times::AbstractVector;\n    interpolations::NamedTuple=NamedTuple(zip(traj.names, fill(:linear, length(traj.names))))\n)\n\nInterpolate a NamedTrajectory at specified time points.\n\nArguments\n\ntraj::NamedTrajectory: The trajectory to interpolate.\ntimes::AbstractVector: The time points at which to interpolate the trajectory.\n\nKeyword Arguments\n\ninterpolations::NamedTuple: A named tuple specifying the interpolation method for each  component. Supported methods are :constant, :linear, and :spline. Defaults to  :linear for all components.\n\nReturns\n\nNamedTrajectory: A new trajectory with interpolated values at the specified times.\n\nNotes\n\nComponents not specified in interpolations will be dropped from the returned trajectory.\nThe timestep component is automatically included with linear interpolation if not specified.\nSpline interpolation requires derivative components (e.g., du for component u).\n\nExamples\n\n# Linear interpolation at new time points\nnew_times = [0.0, 0.5, 1.0, 1.5, 2.0]\nnew_traj = trajectory_interpolation(traj, new_times)\n\n# Mix of interpolation methods\ninterpolations = (x = :linear, u = :spline, Δt = :linear)\nnew_traj = trajectory_interpolation(traj, new_times; interpolations=interpolations)\n\n\n\n\n\ntrajectory_interpolation(\n    traj::NamedTrajectory,\n    T::Int;\n    kwargs...\n)\n\nInterpolate a NamedTrajectory to a new number of time steps.\n\nArguments\n\ntraj::NamedTrajectory: The trajectory to interpolate.\nT::Int: The number of time steps in the interpolated trajectory.\n\nKeyword Arguments\n\nkwargs...: Additional keyword arguments passed to the main trajectory_interpolation method.\n\nReturns\n\nNamedTrajectory: A new trajectory with T time steps, evenly spaced between the original  start and end times.\n\nExamples\n\n# Interpolate to 100 time steps\nnew_traj = trajectory_interpolation(traj, 100)\n\n# With custom interpolation methods\nnew_traj = trajectory_interpolation(traj, 100; interpolations=(x=:spline, u=:linear))\n\n\n\n\n\n","category":"function"},{"location":"generated/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and NamedTrajectories exports a plot function that contains a lot of functionality that is continually being added to.\n\nMakie.jl is used as the plotting framework. An extension package is used to load plotting functionality whenever a version of Makie is installed in the current environment. For example, use CairoMakie to creates high quality vector graphics.\n\nThe main recipe for named trajectory plotting is as follows:\n\nThe plot function is a wrapper around plot_name that allows for easy plotting of NamedTrajectory objects. The plot function has the following signature:\n\nplot(traj::NamedTrajectory, args...; kwargs...)","category":"section"},{"location":"generated/plotting/#Basic-example","page":"Plotting","title":"Basic example","text":"Use a Makie backend to automatically load the NamedTrajectories plotting extension\n\nusing CairoMakie\nusing NamedTrajectories\n\n# define the number timestamps\nN = 100\nΔt = 0.1\nts = [0:N-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, N)\nX[1, :] = sin.(3 * 2π * ts / (2 * (N - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (N - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (N - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V,\n        Δt=fill(Δt, N),\n    );\n    timestep=:Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)","category":"section"},{"location":"generated/plotting/#Selectively-plotting-components","page":"Plotting","title":"Selectively plotting components","text":"We can selectively plot components of the trajectory by passing a Vector of Symbols to the components keyword argument. For example, if we only wanted to plot the state and the first control we could do the following:\n\nplot(traj, [:x, :u])","category":"section"},{"location":"generated/plotting/#Playing-with-transformations","page":"Plotting","title":"Playing with transformations","text":"We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data.\n\nFor example, if we wanted to plot absolute values of the states we could do the following:\n\ntransformations = [(:x => x -> abs.(x))]\n\nplot(traj, [:x]; transformations=transformations)\n\nWe can also pass multiple transformations to the same component, with selective labels and titles:\n\n# define the transformations\ntransformations = [\n    (:x => x -> [x[1] + x[2], x[3] - x[2]]),\n    (:x => x -> [x[1] - x[2], x[3] + x[2]])\n]\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u]; transformations=transformations,)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/plotting/#NamedTrajectories.Plotting.plot_name-generated-plotting","page":"Plotting","title":"NamedTrajectories.Plotting.plot_name","text":"plot_name(traj::NamedTrajectory, name::Symbol; kwargs...)\nplot_name!(ax, traj::NamedTrajectory, name::Symbol; kwargs...)\n\nPlot a single component of a NamedTrajectory using Makie.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"logo\" width=\"25%\"/>\n  </a>\n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/NamedTrajectories/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/NamedTrajectories/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/NamedTrajectories.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/NamedTrajectories.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/NamedTrajectories.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/NamedTrajectories.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n  <i>An elegant way to handle messy trajectory data</i>\n  <br>\n</div>","category":"section"},{"location":"#NamedTrajectories.jl","page":"Home","title":"NamedTrajectories.jl","text":"NamedTrajectories.jl is a package for working with trajectories of named variables. It is designed to be used with the Piccolo.jl ecosystem.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"NamedTrajectories.jl is registered! Install in the REPL by entering pkg mode with ] and then running\n\npkg> add NamedTrajectories","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Abstract away messy indexing and vectorization details required for interfacing with numerical solvers.\nEasily handle multiple trajectories with different names, e.g. various states and controls.\nSimple plotting of trajectories.\nProvide a variety of helpful methods for common tasks.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"Users can define NamedTrajectory types which have lots of useful functionality. For example, you can access the data by name or index.  In the case of an index, a KnotPoint is returned which contains the data for that timestep.\n\nusing NamedTrajectories\n\n# define number of timesteps and timestep\nN = 10\ntimestep=:dt\n\n# build named tuple of components and data matrices\ncomponents = (\n    x  = rand(3, N),\n    u  = rand(2, N),\n    dt = fill(0.1, N),\n)\n\n# build trajectory\ntraj = NamedTrajectory(components; timestep=timestep, controls=:u)\n\n# access data by name\ntraj.x # returns 3x10 matrix of x data\ntraj.u # returns 2x10 matrix of u data\n\nz1 = traj[1] # returns KnotPoint with x and u data\n\nz1.x # returns 3 element vector of x data at timestep 1\nz1.u # returns 2 element vector of u data at timestep 1\n\nz1.dt # returns 10 element vector of timesteps\n\ntraj.data # returns data as 5x10 matrix\ntraj.names # returns names as tuple (:x, :u)\nnothing # hide","category":"section"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"NamedTrajectories.jl is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form\n\nbeginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    nonumber textstqquad  mathbff(mathbfZ) = 0 \n    nonumber  mathbfg(mathbfZ) le 0\nendaligned\n\nwhere mathbfZ is a trajectory.\n\nIn more detail, this problem might look something like\n\nbeginalign*\nundersetu^1_1N dots u^n_c_1Nundersetx^1_1N cdots x^n_s_1Ntextminimize quad J left(x^1n_s_1Nu^1n_c_1N right) \ntextsubject to  quad f left(x^1n_s_1Nu^1n_c_1N right) = 0 \n quad x^i_1 = x^i_textinitial \n quad x^i_N = x^i_textfinal \n quad u^i_1 = u^i_textinitial \n quad u^i_N = u^i_textfinal \n quad x^i_min  x^i_k  x^i_max \n quad u^i_min  u^i_k  u^i_max \nendalign*\n\nwhere x^i_k is the i th state variable and u^i_k is the i th control variable at knot point k; state and control variables can be of arbitrary dimension. The function f is a nonlinear constraint function and J is the objective function. These problems can have an arbitrary number of state (n_s) and control (n_c) variables, and the number of knot points N can vary as well.\n\nIt is common practice in trajectory optimization to bundle all of the state and control variables together into a single knot point\n\nz_k = beginpmatrix\n    x^1_k \n    vdots \n    x^n_s_k \n    u^1_k \n    vdots \n    u^n_c_k\n  endpmatrix\n\nThe trajectory optimization problem can then be succinctly written as\n\nbeginalign*\nundersetz_1Ntextminimize quad J left(z_1N right) \ntextsubject to  quad f left(z_1N right) = 0 \n quad z_1 = z_textinitial \n quad z_N = z_textfinal \n quad z_min  z_k  z_max \nendalign*\n\nThe NamedTrajectories package provides a NamedTrajectory type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a KnotPoint is returned which contains the data for that timestep.","category":"section"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.\n\n# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/\n\nTo build the docs pages:\n\njulia --project=docs docs/make.jl\n\nor editing the docs live:\n\njulia --project=docs\n> using LiveServer, NamedTrajectories, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])\n\nNote: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.\n\nFor example, if we forget index.md like so:\n\njulia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])\n\nit will not build and serve.\n\n\n\n\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry","category":"section"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/#Getting-set-up","page":"Quickstart Guide","title":"Getting set up","text":"To install NamedTrajectories simply enter the package manager in the Julia REPL with ] and run\n\npkg> add NamedTrajectories\n\nThen just use the package as usual with\n\nusing NamedTrajectories\n\nFor the following examples let's work with a simple trajectory\n\nqtyz_k = mqty(x_k  u_k)_k=1N\n\nwhere x_k is the state and u_k is the control at a time indexed by k. Together z_k is referred to as a knot point and a NamedTrajectory essentially just stores a collection of knot points and makes it easy to access the state and control variables.","category":"section"},{"location":"generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","page":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","text":"Here we will create a NamedTrajectory with a variable timestep.\n\n# define the number of timesteps\nN = 10\nΔt = 0.1\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, N),\n    u = rand(2, N),\n    Δt = fill(Δt, N),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory.\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names","category":"section"},{"location":"generated/quickstart/#Adding-more-problem-data","page":"Quickstart Guide","title":"Adding more problem data","text":"In many settings we will want to specify the problem data of our NamedTrajectory – e.g. bounds, initial values, final values, and goal values.\n\n# define the number of timesteps\nN = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, N),\n    u = rand(2, N),\n    Δt = rand(N),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.bounds","category":"section"},{"location":"generated/quickstart/#Retrieving-data","page":"Quickstart Guide","title":"Retrieving data","text":"There are a number of ways to access data, for example\n\ntraj.x\n\nreturns the data matrix associated with the state variable x.\n\ntraj.data\n\nreturns the all of the data as a matrix where each column is a knot point.\n\ntraj.datavec\n\nreturns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers.\n\ntraj[1]\n\nreturns a KnotPoint.\n\ntraj[1].x\n\nreturns the state at the first knot point.\n\nget_times(traj)\n\nreturns the times of the knot points.\n\nget_timesteps(traj)\n\nreturns the timesteps of the knot points, as vector.","category":"section"},{"location":"generated/quickstart/#Retrieving-metadata","page":"Quickstart Guide","title":"Retrieving metadata","text":"We can also retrieve metadata about the trajectory, for example\n\ntraj.names\n\nreturns the names of the variables stored in the trajectory.\n\ntraj.dims\n\nreturns the dimensions of the variables stored in the trajectory.\n\ntraj.N\n\nreturns the number of knot points in the trajectory.\n\ntraj.components\n\nreturns the components of the trajectory.","category":"section"},{"location":"generated/quickstart/#Updating-problem-data","page":"Quickstart Guide","title":"Updating problem data","text":"The NamedTrajectory can be updated by accessing fields and replacing the data.\n\nWe also have update! to update trajectory components, and  update_bound!, which allows you to pass in the same kinds of bounds available at construction (e.g., an Int or Tuple). The bound will get shaped to match the trajectory component dimensions just like at construction. These methods cannot be used to update non-existent bounds or components.\n\nFor efficiency, a trajectory cannot add new data after it is constructed. However, we have convenience methods like add_component that build a new trajectory with added data.\n\nupdate_bound!(traj, :x, 2.) # TODO: consider fleshing out this section with more examples of updating trajectory components, knot points, globals, bounds, etc.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/man/constructors/#Constructors","page":"Constructors","title":"Constructors","text":"To construct a NamedTrajectory using NamedTrajectories.jl, we simply need to utilize the NamedTrajectory constructor.\n\nusing NamedTrajectories\n\n# define number of timesteps and timestep\nN = 10\ndt = 0.1\n\nbuild named tuple of components and data matrices.\n\ncomponents = (\n    x = rand(3, N),\n    u = rand(2, N),\n    Δt = fill(dt, 1, N),\n)\n\nwe must specify a timestep and control variable for the trajectory.\n\ntimestep = :Δt\ncontrol = :u\n\nwe can now create a NamedTrajectory object.\n\ntraj = NamedTrajectory(components; timestep=timestep, controls=control)\n\nConstruct NamedTrajectory from previous constructed one.\n\ntraj = NamedTrajectory(components, traj) # TODO: should this constructor be reimplemented for v0.4.0?\n\ntraj = NamedTrajectory(traj; components=(x=1:3, u=4:5, Δt=6:6))\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
